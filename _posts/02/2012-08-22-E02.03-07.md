---
title:      Exercise 2.3-7
clrs:       [2, 3]
date:       2012-08-22 22:30
---

> Describe a $$\Theta(n \lg n)$$-time algorithm that, given a set $$S$$ of $$n$$ integers and another integer $$x$$, determines whether or not there exist two elements in $$S$$ whose sum is exactly $$x$$.

If the running time constraint was not there, we might have intuitively used the brute-force method of picking one element at a time and iterating over the set to check if there exists another element in the set such that sum of them is $$x$$. Even in average case, this brute-force algorithm will run at $$\Theta(n^2)$$ time (as we have to iterate over the set for each element).

But we have to think of a $$\Theta(n \lg n)$$-time algorithm.

{% capture note %}
Every time we see $$\lg n$$, we should think of divide-and-conquer algorithms. It inherently means how many times $$n$$ can be divided by $$2$$, i.e. repeated division of $$n$$ elements in two  groups.
{% endcapture %}
{% include aside.html type="info" title="Quick Tip" %}

So, the problem asks for a search algorithm and we already know ***binary search*** is an efficient one at that which runs at $$\Theta(\lg n)$$ time for a sorted array (see [Exercise 2.3-5]({{ site.baseurl }}{% post_url /02/2012-08-22-E02.03-05 %})).

So, we can sort the array with merge sort ($$\Theta(n \lg n)$$) and then for each element $$S[i]$$ in the array, we can do a binary search for $$x - S[i]$$ on the sorted array ($$\Theta(n \lg n)$$). So, the overall algorithm will run at $$\Theta(n \lg n)$$ time.

{% capture code %}
Merge-Sort(S, 1, S.length)
for i = 1 to S.length
    if Binary-Search(S, x - S[i]) != NIL
        return true
return false
{% endcapture %}
{% include clrs_code.html title="Sum-Search(S, x)" %}

See chapter text for pseudocode for $$\textsc {Merge-Sort}$$ and [Exercise 2.3-5]({{ site.baseurl }}{% post_url /02/2012-08-22-E02.03-05 %}) for $$\textsc {Binary-Search}$$ (we can use either of iterative and recursive binary search).
