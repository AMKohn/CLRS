---
title:      Exercise 1.2-2
clrs:       [1, 2]
date:       2012-08-19 21:05
code:       true
graph:      true
---

>**Suppose we are comparing implementations of insertion sort and merge sort on the same machine. For inputs of size $$n$$, insertion sort runs in $$8n^2$$ steps, while merge sort runs in $$64n \lg n$$ steps. For which values of $$n$$ does insertion sort beat merge sort?**

For insertion sort to beat merge sort for inputs of size $$n$$, $$8n^2$$ must be less than $$64n \lg n$$.
\$$8n^2 < 64n \lg n \implies \frac n 8 < \lg n \implies 2^{n/8} < n$$

This is not a purely polynomial equation in $$n$$.  To find the required range of values of $$n$$, either we have to manually calculate the values of these expression for different values of $$n$$ or use [Newton's Method](http://en.wikipedia.org/wiki/Newton%27s_method){:target="_blank"} or plot these functions or write a piece of code to found the values. For this exercise, I'll briefly describe all of these methods but going forward I'll mostly use calculations that can be done with scientific calculator (to help the students visiting these pages) and python codes (to help myself).


<br/>
<b><u>Calculate:</u></b>
It is obvious that insertion sort runs at quadratic time which is definitely worse than merge sort's linearithmic time for very large values of $$n$$. We know for $$n = 1$$, merge sort beats insertion sort. But for values greater than that, insertion sort beats merge sort. So, we will start checking from $$n = 2$$ and go up to see for what value of $$n$$ merge sort again starts to beat insertion sort.

Notice that for $$n < 8$$, $$2^{n/8}$$ will be a fraction. So, let's start with $$n = 8$$ and check for values of $$n$$ which are power of 2.

For $$n = 8 \implies 2^{8/8} = 2^1 = 2 < 8$$
For $$n = 16 \implies 2^{16/8} = 2^2 = 4 < 16$$
For $$n = 32 \implies 2^{32/8} = 2^4 = 16 < 32$$
For $$n = 64 \implies 2^{64/8} = 2^8 = 256 > 64 \implies$$ <span style="color: #c55">!!STOP!!</span>

Somewhere between 32 and 64, merge sort starts to beat insertion sort. Let's do what we were doing but now we are going to try middle value of either range, repeatedly (binary search).

For $$n = \frac {32 + 64} 2 = 48 \implies 2^{48/8} = 2^6 = 64 > 48$$
For $$n = \frac {32 + 48} 2 = 40 \implies 2^{40/8} = 2^5 = 32 < 40$$
For $$n = \frac {40 + 48} 2 = 44 \implies 2^{44/8} = 2^5 \times 2^{1/2} > 32 \times 1.4 = 44.8 > 44$$
For $$n = \frac {40 + 44} 2 = 42 \implies 2^{42/8} = 2^5 \times 2^{1/4} < 32 \times 1.2 = 38.4 < 42$$
For $$n = \frac {42 + 44} 2 = 43 \implies 2^{43/8} = 2^5 \times 2^{1/4} \times 2^{1/8} < 32 \times 1.2 \times 1.1 = 42.4 < 43 \implies$$ <span style="color: #c55">!!STOP!!</span>

So, at $$n = 44$$, merge sort starts to beat insertion sort again.
So, for $$1 < n < 44$$, insertion sort beats merge sort.

<br/>
<b><u>Newton's Method:</u></b>
To apply Newton's method of approximation, we need to ballpark two values of $$n$$ on either side of the actual solution and hit-and-try for the actual one following binary search principle. The proper method to do so is too time consuming for me.

<br/>
<b><u>Graphical Plot:</u></b>
Plot the functions $$2^{n/8}$$ and $$n$$ to get the points where they intersect.
{% include graph_box.html %}
<script type="text/javascript">
    var board = JXG.JSXGraph.initBoard('graph-box', {boundingbox:[-5, 60, 50, -5], axis:true, showCopyright:false, showNavigation:false});
    var merge = board.create('functiongraph', [function(x){return x;}], {withLabel: true, name: "Insertion Sort", label: {offset:[-40,40]}});
    var insrt = board.create('functiongraph', [function(x){return Math.pow(2, x/8.0);}], {withLabel: true, name: "Merge Sort", label: {offset:[200,50]}});
    var ans_1 = board.create('intersection', [merge, insrt, 0]);
    var ans_2 = board.create('intersection', [merge, insrt, 1]);
</script>
From the above graph, we can see that the plots intersect at $$n = 1.1$$ and $$n = 43.56$$. Here, $$n$$ is a input size so it must be an integer. So, the values of $$n$$ for which insertion beats merge sort is $$ 1 < n < 44$$.

<br/>
<b><u>Python Code:</u></b>
Let's start with $$n = 2$$ and go up to see for what value of $$n$$ merge sort again starts to beat insertion sort.

<div class="clrs-code-wrapper">
<textarea id="clrs-code" data-editor="python" rows="10">
n = 2
while 2 ** (n / 8.0) < n:
    n += 1

print "Maximum value of n for which insertion sort beats merge sort is", n - 1
{% include code_editor.html %}